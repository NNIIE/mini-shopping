## 이미지 업로드
### 클라이언트 -> S3
백엔드에서 인증/인가 후 짧은 유효기간의 pre-signed URL 발급하면(임시 업로드 권한) 프론트엔드가 S3에 직접 업로드
- 리소스
  - 저장공간
    - pre-signed URL 응답에 순간 최대 메모리 약 2KB 필요
    - 이미지 크기에 상관없이 메모리 예측 가능
  - 비용: S3 저장 비용만 발생
- 장점
  - 백엔드 부하/트래픽: 이미지 데이터가 백엔드를 통과하지 않아 서버 비용 및 리소스 소모 거의 없음
  - 업로드 속도: 유저 네트워크 → S3로 바로 전송되어 대용량/대량 이미지도 빠르게 처리 가능
  - 확장성: 동시 접속/업로드가 많아져도 백엔드 서버 부하 영향 적음
  - 비용: S3 저장 비용 + S3 PUT 요청 비용
- 단점
  - 파일 검증: 별도의 처리 없으면 Content-Type, 파일명 등 메타데이터 수준의 제한만 가능
    - Content-Type/확장자를 위장해 악성 파일 업로드 가능

### 클라이언트 -> 백엔드 -> S3
모든 업로드가 백엔드를 거쳐 S3로 전송되는 방식
- 리소스
  - 저장공간
    - 메모리 버퍼 사용 시
      - 이미지 크기 만큼 메모리 점유
    - 임시파일 디스크 사용 시
      - 8KB(네트워크 버퍼) + 1KB(MultipartFile 객체) 
      - 메모리 사용량: 9~10KB
      - 디스크 공간: 이미지 크기만큼 디스크 점유
  - 비용: S3 저장비용 + 더 큰 백엔드 서버 비용 발생
- 장점
  - 파일 검증: Content-Type, 파일 확장자, 실제 바이너리 파일, 해상도, 크기, 악성코드 여부 등 세밀한 검증 가능
  - 서비스 정책: 모든 이미지에 대해 포맷, 용량, 워터마크, 압축 등의 정책을 서버에서 일괄 적용 가능
  - 실패 시 명확한 메시지 및 관리 가능
- 단점
  - 백엔드 부하/트래픽: 모든 파일이 백엔드 서버를 통과하므로 대용량/대량 업로드 시 서버 부하 부하증가
  - 업로드 속도: 프론트 → 백엔드 → S3 이기 때문에 Pre-signed URL 방식보다 느림
  - 확장성: 동시 접속/업로드가 많아지면 백엔드 서버 증설 필요
  - 비용: 더 큰 서버 인스턴스 비용 필요

<br>

## 고민거리
### 썸네일: 클라이언트에서 이미지 처리 후 업로드
클라이언트 자원을 활용하여 썸네일을 처리하는 방식
- 장점
  - 서버 리소스 절감
  - 이미지 미리보기 가능
- 단점
  - 클라이언트 의존
    - 호환성 문제
    - 클라이언트마다 품질이 다를 수 있음
    - 별도의 처리가 없다면 Content-Type 등을 속여서 업로드 하는걸 막을 수 없음
      - ex) 악성코드등을 이미지로 위장하여 업로드하고 다운로드 되게 끔

### 썸네일: pre-signed URL(원본이미지 버킷) -> Lambda(썸네일 생성) -> S3(썸네일 버킷에 저장)
- 장점
  - 확장성
    - Lambda가 자동으로 확장되어 대량의 이미지 업로드를 처리할 수 있음
- 단점
  - 최대 15분/10GB 제한
  - Lambda 처리 실패시 썸네일 생성 누락등의 정합성 문제
  - 로컬테스트 어려움

### 썸네일: 다운로드 시 이미지 처리
업로드 직후가 아닌 실제 다운로드가 발생할 때 썸네일을 생성하는 방식
- 장점
  - 스토리지 절약
    - 여러 사이즈의 썸네일을 미리 저장할 필요가 없음
  - 다양한 크기 요청에 즉시 대응
- 단점
  - 다운로드 시 첫 지연 발생

### Lambda 이미지 프로세싱 실패
메모리 부족, 타임아웃, 네트워크, 손상된 파일, 포맷, 권한 등 다양한 이유로 실패 가능성 존재
- 일시적인 실패의 경우(메모리, 네트워크 등) Lambda 재시도로 해결과 DLQ 전송
- DLQ(Dead Letter Queue)
  - DLQ로 전송하여 실패 로그 보관
  - 슬랙 알람등을 활용하여 관리자에게 알림

### 원본 이미지 URl 데이터베이스 저장
- 클라이언트가 업로드에 성공한 후 백엔드에 원본 이미지 URL 저장 api 호출
  - 추가적인 AWS 서비스 구성 없이 구현 가능
    - 백엔드에서 파일존재여부는 검증해야 함
  - 업로드는 성공했지만 네트워크 문제등으로 API 호출 실패 가능성 존재
- S3 이벤트 발생 시 Lambda 함수를 통해 SQS로 메시지 전송 -> 백엔드에서 메시지 수신 후 데이터베이스 저장
  - S3에 이미지가 존재하는 경우에만 메시지가 전송되므로 데이터 정합성 보장
  - 이벤트 전파와 Lambda 콜드 스타트로 인한 수초의 딜레이가 발생할 수 있음
  - SQS, DLQ, Lambda 등 AWS 서비스 추가 구성 필요

<br>

## 최종 선택 (Pre-Signed URL + 클라이언트 썸네일 이미지 프로세싱 + Lambda + SQS)
백엔드 서버의 부하를 최소화 하면서 데이터 정합성을 보장할 수 있는 조합
- 장점
  - 서버 부하 감소
    - S3가 업로드 트래픽 처리
    - pre-signed url 생성은 비교적 가벼운 작업
    - 클라이언트 자원을 활용하여 썸네일을 처리하므로 서버 리소스 절감
  - 데이터 무결성
    - 업로드 성공 후 API 호출 실패로 인한 데이터 불일치 방지
    - S3 버킷에 이미지가 생성되어야만 데이터베이스에 저장되므로 데이터 정합성 보장
  - 유저 경험
    - 썸네일 즉시 미리보기 가능
- 단점
  - 보안 위험
    - Content-Type 등 헤더 우회 가능
    - 바이너리 파일 검증 불가능
    - 대안
      - AWS GuardDuty Malware Protection
        - 멀웨어 스캐닝 엔진을 사용하는 AWS 관리형 서비스
      - S3 이벤트 - Lambda 를 통한 이미지 업로드 후 사후 검증
      - 클라이언트 검증 강화
  - SQS 메시지 전송 실패 시 DLQ 로 전송되어야 하므로 추가적인 AWS 서비스 구성 필요

### Flow
- 클라이언트가 백엔드로 pre-signed URL 발급 요청
  - 썸네일 이미지 추가 여부 포함
- 백엔드가 S3 pre-signed URL 발급
  - 원본 S3 버킷 pre-signed URL
  - 썸네일 S3 버킷 pre-signed URL
- 클라이언트가 pre-signed URL을 통해 S3에 이미지 업로드
  - 원본 S3 버킷
  - 썸네일 S3 버킷
- S3 PUT 이벤트 발생 -> Lambda 함수 실행
- Lambda 함수가 원본 이미지 URL을 SQS에 전송
  - 실패 시 DLQ로 전송
- 백엔드 어플리케이션에서 SQS 메시지 수신
  - DLQ로 전송된 메시지가 있으면 슬랙등을 통해 관리자에게 알림
- 원본 이미지 URL을 데이터베이스에 저장

<br>

## 다운로드
### Download Flow - 간단
1. CloudFront 가 썸네일 이미지 요청을 받음
2. DNS 를 통해 가장 가까운 엣지 로케이션으로 연결
3. 서울 썸네일 이미지 버킷에서 이미지 다운로드 및 캐시에 저장
4. 추후 같은 요청이 들어오면 캐시된 이미지 제공

<br>

## 최적화
표준 크기들의 썸네일들을 미리 생성해두고 특별한 크기가 필요할 때 CloudFront 를 통해 실시간 리사이징을 사용하는 방식 채택
- 썸네일 생성
  - Sharp / Canvas / Jimp 등을 사용하여 이미지 리사이징
- 실시간 리사이징
  - 파라미터를 받아 CloudFront 를 통해 실시간 이미지 최적화






