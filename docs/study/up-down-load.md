## 이미지 업로드

| 원본 이미지    | Pre-Signed URL                     | 백엔드 경유                                                                                                                     |
|-----------|------------------------------------|----------------------------------------------------------------------------------------------------------------------------|
| 서버 리소스    | - pre-signed URL 응답에 순간 최대 메모리 약 2KB | 메모리 버퍼 사용 시 <br>- 메모리 5MB <br>임시 디스크 사용 시 <br>- 8KB(네트워크 버퍼) + 1KB(MultipartFile 객체) <br>- 메모리 사용량: 9~10KB <br>- 디스크 공간: 5MB |
| 업로드 속도    |                                    |                                                                                                                            |
| 확장성       | - S3가 트래픽 분산 처리                    | - scale-out 필요                                                                                                             |
| 비용        | - 0.025/GB/월 + 0.005/1,000회        | - 0.025/GB/월 + 0.005/1,000회 + scale-out 시 추가 인스턴스 비용                                                                       |
| trade-off |                                    |                                                                                                                            |

- TEST 환경
  - AWS ECS + Fargate + ECR + S3 + 서울 리전
  - cpu: 256 vCPU 단위 (0.25 vCPU)
  - ram: 512 MB
  - 플랫폼: Linux x86_64
  - application
    - java21 + Spring Boot 3.4.4
  - 이미지: 5MB를 서울에서 업로드 

### 클라이언트 -> S3
백엔드에서 인증/인가 후 짧은 유효기간의 pre-signed URL 발급하면(임시 업로드 권한) 프론트엔드가 S3에 직접 업로드
- 리소스
  - 저장공간
    - pre-signed URL 응답에 순간 최대 메모리 약 2KB 필요
    - 이미지 크기에 상관없이 메모리 예측 가능
  - 비용: S3 비용 (저장 + PUT 요청)
- 장점
  - 백엔드 부하/트래픽: 이미지 데이터가 백엔드를 통과하지 않아 서버 비용 및 리소스 소모 거의 없음
  - 업로드 속도: 유저 네트워크 → S3로 바로 전송되어 대용량/대량 이미지도 빠르게 처리 가능
  - 확장성: 동시 접속/업로드가 많아져도 백엔드 서버 부하 영향 적음
  - 비용: S3 비용 (저장 + PUT 요청)
- 단점
  - 파일 검증: 별도의 처리 없으면 Content-Type, 파일명 등 메타데이터 수준의 제한만 가능
    - Content-Type/확장자를 위장해 악성 파일 업로드 가능

### 클라이언트 -> 백엔드 -> S3
모든 업로드가 백엔드를 거쳐 S3로 전송되는 방식
- 리소스
  - 저장공간
    - 메모리 버퍼 사용 시
      - 이미지 크기 만큼 메모리 점유
    - 임시파일 디스크 사용 시
      - 8KB(네트워크 버퍼) + 1KB(MultipartFile 객체) 
      - 메모리 사용량: 9~10KB
      - 디스크 공간: 이미지 크기만큼 디스크 점유
  - 비용: S3 비용 (저장 + PUT 요청) + 더 큰 백엔드 서버 비용 발생
- 장점
  - 파일 검증: Content-Type, 파일 확장자, 실제 바이너리 파일, 해상도, 크기, 악성코드 여부 등 세밀한 검증 가능
  - 서비스 정책: 모든 이미지에 대해 포맷, 용량, 워터마크, 압축 등의 정책을 서버에서 일괄 적용 가능
  - 실패 시 명확한 메시지 및 관리 가능
- 단점
  - 백엔드 부하/트래픽: 모든 파일이 백엔드 서버를 통과하므로 대용량/대량 업로드 시 서버 부하 부하증가
  - 업로드 속도: 프론트 → 백엔드 → S3 이기 때문에 Pre-signed URL 방식보다 느림
  - 확장성: 동시 접속/업로드가 많아지면 백엔드 서버 증설 필요
  - 비용: 더 큰 서버 인스턴스 비용 필요

<br>

## 고민거리
### 썸네일: 클라이언트에서 이미지 처리 후 업로드
클라이언트 자원을 활용하여 썸네일을 처리하는 방식
- 장점
  - 서버 리소스 절감
  - 이미지 미리보기 가능
- 단점
  - 클라이언트 호환성
    - ex) 브라우저마다 EXIF 회전정보 처리 방식이 다름
    - ex) Canvas 랜더링 엔진 차이, 색상 프로파일 처리 차이
  - 업로드 후 별도로 악성파일 검증 필요
    - 클라이언트에서 바로 썸네일을 생성하는 경우 바이너리 파일 검증 불가

### 썸네일: pre-signed URL(원본이미지 버킷) -> Lambda(썸네일 생성) -> S3(썸네일 버킷에 저장)
- 장점
  - 확장성
    - Lambda가 자동으로 확장되어 대량의 이미지 업로드를 처리할 수 있음
- 단점
  - 최대 15분/10GB 제한
  - Lambda 처리 실패시 썸네일 생성 누락등의 정합성 문제
  - 로컬테스트 어려움

### 썸네일: 다운로드 시 이미지 처리
업로드 직후가 아닌 실제 다운로드가 발생할 때 썸네일을 생성하는 방식
- 장점
  - 스토리지 절약
    - 여러 사이즈의 썸네일을 미리 저장할 필요가 없음
  - 다양한 크기 요청에 즉시 대응
- 단점
  - 다운로드 시 첫 지연 발생
    - 대략 0.5 ~ 2초의 지연 발생 (1MB ~ 5MB 이미지 기준)
      - 콜드스타트: 300 ~ 800ms
      - 원본 이미지 다운로드: 50~200ms
      - 썸네일 생성: 100 ~ 800ms

### Lambda 이미지 프로세싱 실패
메모리 부족, 타임아웃, 네트워크, 손상된 파일, 포맷, 권한 등 다양한 이유로 실패 가능성 존재
- 일시적인 실패의 경우(메모리, 네트워크 등) Lambda 재시도로 해결과 DLQ 전송
- DLQ(Dead Letter Queue)
  - DLQ로 전송하여 실패 로그 보관
  - 슬랙 알람등을 활용하여 관리자에게 알림

### 원본 이미지 URl 데이터베이스 저장
- 클라이언트가 업로드에 성공한 후 백엔드에 원본 이미지 URL 저장 api 호출
  - 추가적인 AWS 서비스 구성 없이 구현 가능
    - 백엔드에서 파일존재여부는 검증해야 함
  - 업로드는 성공했지만 네트워크 문제등으로 API 호출 실패 가능성 존재
- S3 이벤트 발생 시 Lambda 함수를 통해 SQS로 메시지 전송 -> 백엔드에서 메시지 수신 후 데이터베이스 저장
  - S3에 이미지가 존재하는 경우에만 메시지가 전송되므로 데이터 정합성 보장
  - 이벤트 전파와 Lambda 콜드 스타트로 인한 수초의 딜레이가 발생할 수 있음
  - SQS, DLQ, Lambda 등 AWS 서비스 추가 구성 필요

<br>

## 최종 선택 (Pre-Signed URL + 클라이언트 썸네일 이미지 프로세싱 + Lambda + SQS/DLQ)
| 원본 이미지    | Pre-Signed URL       | 백엔드 경유             |
|-----------|----------------------|--------------------|
| 백엔드 부하    | 매우 낮음<br>- URL 생성: 평균 2ms<br>- 메모리: 2KB  | 높음<br>- 이미지 크기만큼 메모리 점유<br>- 5MB 이미지시 5MB 메모리 필요 |
| 확장성       | - S3가 트래픽 분산 처리             | - scale-out 필요     |
| 보안        | - 사전 검증 불가, 사후 검증 필요 | - 가전 검증 가능         |
| 비용        | - S3 비용              | - S3 비용 + 인스턴스 비용  |

| 썸네일    | 클라이언트 썸네일 생성 | Lambda 썸네일 생성             | 다운로드 시 썸네일 생성                          |
|--------|--------------|---------------------------|----------------------------------------|
| 처리 위치  | - 클라이언트      | - AWS Lambda              | - CloudFront + Lambda@Edge             |
| 백엔드 부하 | - 없음         | - 없음                      | - 없음                                   |
| 초기 지연  | - 없음         | - 없음                      | - 이미지 크기에 따라 존재 <br>- 5~10MB 기준 0.5 ~ 2초 |
| 저장     | - 항상 저장      | - 항상 저장                   | - 요청이 왔을때만 생성 후 저장                     |
| 실패 대응  | - 사용자 재시도    | - DLQ(관리자 개입 필요) + 자동 재시도 | - 실시간 재시도                              |
```
- 원본 이미지: Pre-Signed URL
  - 백엔드 서버의 부하를 최소화 하면서 사후 검증(GuardDuty Malware Protection, Lambda 등)으로 보안에 대한 위협을 줄일 수 있음
- 썸네일 이미지: 클라이언트 썸네일 생성
  - 사용자 경험(미리보기 + 첫 지연 없음) + 클라이언트 자원 사용 + 썸네일 생성 실패 시 재시도 책임을 클라이언트에게 위임
- 본 프로젝트에서는 S3/Lambda/SQS 학습을 위해 Pre-Signed URL + 클라이언트 썸네일 생성 + Lambda + SQS 조합을 선택
```
Pre-Signed URL + 클라이언트 썸네일 이미지 프로세싱 + Lambda + SQS/DLQ
- 장점
  - 서버 부하 감소
    - S3가 업로드 트래픽 처리
    - pre-signed url 생성은 비교적 가벼운 작업
    - 클라이언트 자원을 활용하여 썸네일을 처리하므로 서버 리소스 절감
  - 데이터 무결성
    - 업로드 성공 후 API 호출 실패로 인한 데이터 불일치 방지
    - S3 버킷에 이미지가 생성되어야만 데이터베이스에 저장되므로 데이터 정합성 보장
  - 유저 경험
    - 썸네일 즉시 미리보기 가능
- 단점
  - 보안 위험
    - 바이너리 파일 검증 불가능
    - 대안
      - AWS GuardDuty Malware Protection
        - 멀웨어 스캐닝 엔진을 사용하는 AWS 관리형 서비스
      - S3 이벤트 - Lambda 를 통한 이미지 업로드 후 사후 검증
      - 클라이언트 검증 강화
  - SQS 메시지 전송 실패 시 DLQ 로 전송되어야 하므로 추가적인 AWS 서비스 구성 필요
  - 비용
    - SQS: 첫 100만 무료(월) + 이후 1백만 건당 $0.4
    - DLQ: SQS 와 동일
    - Lambda: 1백만 무료(월) + 이후 1백만 요청당 $0.2
    - DLQ로 전송된 메시지에 대한 관리 비용 (인건비)

### Flow
- 클라이언트가 백엔드로 pre-signed URL 발급 요청
  - 썸네일 이미지 추가 여부 포함
- 백엔드가 S3 pre-signed URL 발급
  - 원본 S3 버킷 pre-signed URL
  - 썸네일 S3 버킷 pre-signed URL
- 클라이언트가 pre-signed URL을 통해 S3에 이미지 업로드
  - 원본 S3 버킷
  - 썸네일 S3 버킷
- S3 PUT 이벤트 발생 -> Lambda 함수 실행
- Lambda 함수가 원본 이미지 URL을 SQS에 전송
  - 실패 시 DLQ로 전송
- 백엔드 어플리케이션에서 SQS 메시지 수신
  - DLQ로 전송된 메시지가 있으면 슬랙등을 통해 관리자에게 알림
- 원본 이미지 URL을 데이터베이스에 저장

<br>

## 다운로드
### Download Flow - 간단
1. CloudFront 가 썸네일 이미지 요청을 받음
2. DNS 를 통해 가장 가까운 엣지 로케이션으로 연결
3. 서울 썸네일 이미지 버킷에서 이미지 다운로드 및 캐시에 저장
4. 추후 같은 요청이 들어오면 캐시된 이미지 제공

<br>

## 최적화
표준 크기들의 썸네일들을 미리 생성해두고 특별한 크기가 필요할 때 CloudFront 를 통해 실시간 리사이징을 사용하는 방식 채택
- 썸네일 생성
  - Sharp / Canvas / Jimp 등을 사용하여 이미지 리사이징
- 실시간 리사이징
  - 파라미터를 받아 CloudFront 를 통해 실시간 이미지 최적화






